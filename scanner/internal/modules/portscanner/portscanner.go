package portscanner

import (
	"context"
	"fmt"
	"golang.org/x/sync/semaphore"
	"net"
	"strings"
	"sync"
	"time"
)

var concurrentRequestLimit = 5000

func NewScan(ip string) *Task {
	task := &Task{
		c: make(chan struct{}, 1),
		ps: &PortScanner{
			ip:      ip,
			lock:    semaphore.NewWeighted(int64(concurrentRequestLimit)),
			results: []int{},
		},
	}

	go func() {
		task.ps.Start(1, 65535, 500*time.Millisecond)
		task.c <- struct{}{}
	}()

	return task
}

func ScanPort(ip string, port int, timeout time.Duration) bool {
	var target string
	if checkIPAddressType(ip) == "IPv4" {
		target = fmt.Sprintf("%s:%d", ip, port)
	} else {
		target = fmt.Sprintf("[%s]:%d", ip, port)
	}

	conn, err := net.DialTimeout("tcp", target, timeout)

	if err != nil {
		if strings.Contains(err.Error(), "too many open files") {
			time.Sleep(timeout)
			return ScanPort(ip, port, timeout)
		}
		return false
	}
	conn.Close()
	return true
}

func (ps *PortScanner) Start(f, l int, timeout time.Duration) {
	wg := sync.WaitGroup{}
	defer wg.Wait()

	for port := f; port <= l; port++ {
		ps.lock.Acquire(context.TODO(), 1)
		wg.Add(1)
		go func(port int) {
			defer ps.lock.Release(1)
			defer wg.Done()
			if ScanPort(ps.ip, port, timeout) {
				ps.results = append(ps.results, port)
			}
		}(port)
	}
}

func (task *Task) IsDone() bool {
	if len(task.c) == 1 {
		return true
	}
	return false
}

func (task *Task) GetData() []int {
	return task.ps.results
}

func (task *Task) SaveResults() {
	SaveResults(task.GetData(), task.ps.ip)
}

func checkIPAddressType(ip string) string {
	if net.ParseIP(ip) == nil {
		return ""
	}
	for i := 0; i < len(ip); i++ {
		switch ip[i] {
		case '.':
			return "IPv4"
		case ':':
			return "IPv6"
		}
	}

	return ""
}
